//
//  SBR_StyleKitExported.m
//  Lab-VC-Transitions
//
//  Created by Chris Mitchelmore on 06/06/2014.
//  Copyright (c) 2014 Air Craft. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "SBR_StyleKitExported.h"
#import "SBR_StyleKit.h"


@implementation SBR_StyleKitExported

#pragma mark Initialization
//// Image Declarations
static UIImage *calibrateString;
static UIImage* gestureIcon;
//// Sizes
static CGFloat gap = 2;
static CGFloat glowWidth = 9;
static CGFloat lineWidth = 1;
static CGFloat endLength = 15;
//// Color Declarations
static UIColor* outlineColor;
static UIColor* inlineColor;
static UIColor* backgroundColor;
static UIColor* excludeOutlineColor;
static UIColor* excludeInlineColor;
+ (void)initialize
{
    calibrateString = [SBR_StyleKit imageForSettingsMenuGlowingTextButtonWithText:NSLocalizedString(@"CALIBRATE", nil) highlighted:NO];
    gestureIcon = [UIImage imageNamed: @"gestureIcon"];
    outlineColor = [UIColor colorWithRed: 0.129 green: 0.675 blue: 0.988 alpha: 1];
    inlineColor = [UIColor colorWithRed: 0.133 green: 0.216 blue: 0.231 alpha: 1];
    backgroundColor = [UIColor colorWithRed: 0.082 green: 0.082 blue: 0.067 alpha: 1];
    excludeOutlineColor = [UIColor colorWithRed: 0.915 green: 0.363 blue: 0.363 alpha: 1];
    excludeInlineColor = [UIColor colorWithRed: 0.371 green: 0.249 blue: 0.249 alpha: 1];
}

#pragma mark Drawing Methods

+ (void)drawCircularCalibratorWithFrame: (CGRect)frame maximum: (CGFloat)maximum minimum: (CGFloat)minimum showExluded: (BOOL)showExluded excludeMinimum: (CGFloat)excludeMinimum excludeMaximum: (CGFloat)excludeMaximum alignment:(SBRWidgetOrientation)orientation;
{
    CGFloat offset = orientation == SBRWidgetOrientationLeft ? 90 : -90;
    maximum += offset;
    minimum += offset;
    excludeMinimum += offset;
    excludeMaximum += offset;
    
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Relative
    CGFloat width = MIN(frame.size.height,frame.size.width);

    //// Variable Declarations
    CGFloat minExcludedEnd = maximum;
    CGFloat minEnd = minimum - 90;
    CGFloat minimumMin = minimum;
    CGFloat minimumMax = excludeMinimum;
    CGFloat maxExcludedEnd = excludeMaximum - 90;
    CGFloat maxExcludedOutline = excludeMaximum;
    CGFloat minExcludedEndRed = excludeMinimum - (90 + gap);
    CGFloat minExcludedOutlineRed = minExcludedEndRed + 90;
    CGFloat maxExcludedEndRed = gap + excludeMaximum;
    

    //// Group
    {
        //// Background Drawing
        UIBezierPath* backgroundPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(CGRectGetMinX(frame), CGRectGetMinY(frame), width, width)];
        [backgroundColor setFill];
        [backgroundPath fill];


        if (showExluded)
        {
            //// Inner 2 Drawing
            CGRect inner2Rect = CGRectMake(CGRectGetMinX(frame) + glowWidth/2.0, CGRectGetMinY(frame) + glowWidth/2.0, width-glowWidth, width-glowWidth);
            UIBezierPath* inner2Path = UIBezierPath.bezierPath;
            [inner2Path addArcWithCenter: CGPointMake(CGRectGetMidX(inner2Rect), CGRectGetMidY(inner2Rect)) radius: CGRectGetWidth(inner2Rect) / 2 startAngle: -maxExcludedOutline * M_PI/180 endAngle: -minExcludedEnd * M_PI/180 clockwise: YES];

            [inlineColor setStroke];
            inner2Path.lineWidth = glowWidth;
            [inner2Path stroke];


            //// Negative End 2 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + width/2.0, CGRectGetMinY(frame) + width/2.0);
            CGContextRotateCTM(context, -maxExcludedEnd * M_PI / 180);

            UIBezierPath* negativeEnd2Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(lineWidth/-2.0, width/-2.0, lineWidth, endLength) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(lineWidth/2.0, lineWidth/2.0)];
            [negativeEnd2Path closePath];
            [outlineColor setFill];
            [negativeEnd2Path fill];

            CGContextRestoreGState(context);


            //// Outline 2 Drawing
            CGRect outline2Rect = CGRectMake(CGRectGetMinX(frame) + lineWidth/2.0, CGRectGetMinY(frame) + lineWidth/2.0, width-lineWidth, width-lineWidth);
            UIBezierPath* outline2Path = UIBezierPath.bezierPath;
            [outline2Path addArcWithCenter: CGPointMake(CGRectGetMidX(outline2Rect), CGRectGetMidY(outline2Rect)) radius: CGRectGetWidth(outline2Rect) / 2 startAngle: -maxExcludedOutline * M_PI/180 endAngle: -minExcludedEnd * M_PI/180 clockwise: YES];

            [outlineColor setStroke];
            outline2Path.lineWidth = lineWidth;
            [outline2Path stroke];


            //// Positive End 2 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + width/2.0, CGRectGetMinY(frame) + width/2.0);
            CGContextRotateCTM(context, -minExcludedEnd * M_PI / 180);

            UIBezierPath* positiveEnd2Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(width/2.0-endLength, lineWidth/-2.0, endLength, lineWidth) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(lineWidth/2.0, lineWidth/2.0)];
            [positiveEnd2Path closePath];
            [outlineColor setFill];
            [positiveEnd2Path fill];

            CGContextRestoreGState(context);
        }


        //// Inner Drawing
        CGRect innerRect = CGRectMake(CGRectGetMinX(frame) + glowWidth/2.0, CGRectGetMinY(frame) + glowWidth/2.0, width-glowWidth, width-glowWidth);
        UIBezierPath* innerPath = UIBezierPath.bezierPath;
        [innerPath addArcWithCenter: CGPointMake(CGRectGetMidX(innerRect), CGRectGetMidY(innerRect)) radius: CGRectGetWidth(innerRect) / 2 startAngle: -minimumMin * M_PI/180 endAngle: -minimumMax * M_PI/180 clockwise: YES];

        [inlineColor setStroke];
        innerPath.lineWidth = glowWidth;
        [innerPath stroke];


        //// Negative End Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + width/2.0, CGRectGetMinY(frame) + width/2.0);
        CGContextRotateCTM(context, -minEnd * M_PI / 180);

        UIBezierPath* negativeEndPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(lineWidth/-2.0, width/-2.0, lineWidth, endLength) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(lineWidth/2.0, lineWidth/2.0)];
        [negativeEndPath closePath];
        [outlineColor setFill];
        [negativeEndPath fill];

        CGContextRestoreGState(context);


        //// Outline Drawing
        CGRect outlineRect = CGRectMake(CGRectGetMinX(frame) + lineWidth/2.0, CGRectGetMinY(frame) + lineWidth/2.0, width-lineWidth, width-lineWidth);
        UIBezierPath* outlinePath = UIBezierPath.bezierPath;
        [outlinePath addArcWithCenter: CGPointMake(CGRectGetMidX(outlineRect), CGRectGetMidY(outlineRect)) radius: CGRectGetWidth(outlineRect) / 2 startAngle: -minimumMin * M_PI/180 endAngle: -minimumMax * M_PI/180 clockwise: YES];

        [outlineColor setStroke];
        outlinePath.lineWidth = lineWidth;
        [outlinePath stroke];


        //// Positive End Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + width/2.0, CGRectGetMinY(frame) + width/2.0);
        CGContextRotateCTM(context, -minimumMax * M_PI / 180);

        UIBezierPath* positiveEndPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(width/2.0-endLength, lineWidth/-2.0, endLength, lineWidth) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(lineWidth/2.0, lineWidth/2.0)];
        [positiveEndPath closePath];
        [outlineColor setFill];
        [positiveEndPath fill];

        CGContextRestoreGState(context);


        if (showExluded)
        {
            //// Inner 3 Drawing
            CGRect inner3Rect = CGRectMake(CGRectGetMinX(frame) + glowWidth/2.0, CGRectGetMinY(frame) + glowWidth/2.0, width-glowWidth, width-glowWidth);
            UIBezierPath* inner3Path = UIBezierPath.bezierPath;
            [inner3Path addArcWithCenter: CGPointMake(CGRectGetMidX(inner3Rect), CGRectGetMidY(inner3Rect)) radius: CGRectGetWidth(inner3Rect) / 2 startAngle: -minExcludedOutlineRed * M_PI/180 endAngle: -maxExcludedEndRed * M_PI/180 clockwise: YES];

            [excludeInlineColor setStroke];
            inner3Path.lineWidth = glowWidth;
            [inner3Path stroke];


            //// Negative End 3 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + width/2.0, CGRectGetMinY(frame) + width/2.0);
            CGContextRotateCTM(context, -minExcludedEndRed * M_PI / 180);

            UIBezierPath* negativeEnd3Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(lineWidth/-2.0, width/-2.0, lineWidth, endLength) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(lineWidth/2.0, lineWidth/2.0)];
            [negativeEnd3Path closePath];
            [excludeOutlineColor setFill];
            [negativeEnd3Path fill];

            CGContextRestoreGState(context);


            //// Outline 3 Drawing
            CGRect outline3Rect = CGRectMake(CGRectGetMinX(frame) + lineWidth/2.0, CGRectGetMinY(frame) + lineWidth/2.0, width-lineWidth, width-lineWidth);
            UIBezierPath* outline3Path = UIBezierPath.bezierPath;
            [outline3Path addArcWithCenter: CGPointMake(CGRectGetMidX(outline3Rect), CGRectGetMidY(outline3Rect)) radius: CGRectGetWidth(outline3Rect) / 2 startAngle: -minExcludedOutlineRed * M_PI/180 endAngle: -maxExcludedEndRed * M_PI/180 clockwise: YES];

            [excludeOutlineColor setStroke];
            outline3Path.lineWidth = lineWidth;
            [outline3Path stroke];


            //// Positive End 3 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + width/2.0, CGRectGetMinY(frame) + width/2.0);
            CGContextRotateCTM(context, -maxExcludedEndRed * M_PI / 180);

            UIBezierPath* positiveEnd3Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(width/2.0-endLength, lineWidth/-2.0, endLength, lineWidth) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(lineWidth/2.0, lineWidth/2.0)];
            [positiveEnd3Path closePath];
            [excludeOutlineColor setFill];
            [positiveEnd3Path fill];

            CGContextRestoreGState(context);
        }


        //// Dive Icon Drawing
        CGRect diveIconRect = CGRectMake(CGRectGetMinX(frame) + width*0.3, CGRectGetMinY(frame) + width*0.25, width*0.4, width*0.4);
        UIBezierPath* diveIconPath = [UIBezierPath bezierPathWithRect: diveIconRect];
        CGContextSaveGState(context);
        [diveIconPath addClip];
        [gestureIcon drawInRect: diveIconRect];
        CGContextRestoreGState(context);


        //// Calibrate Message Drawing
        CGRect calibrateMessageRect = CGRectMake(CGRectGetMinX(frame) + width/5.0, CGRectGetMaxY(diveIconRect), 3*(width/5.0), width/9.0);
        UIBezierPath* calibrateMessagePath = [UIBezierPath bezierPathWithRect: calibrateMessageRect];
        CGContextSaveGState(context);
        [calibrateMessagePath addClip];
        [calibrateString drawInRect: calibrateMessageRect];
        CGContextRestoreGState(context);
    }
}

@end
