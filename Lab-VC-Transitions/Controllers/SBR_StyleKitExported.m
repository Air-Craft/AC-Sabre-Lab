//
//  SBR_StyleKitExported.m
//  Lab-VC-Transitions
//
//  Created by Chris Mitchelmore on 06/06/2014.
//  Copyright (c) 2014 Air Craft. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "SBR_StyleKitExported.h"
#import "SBR_StyleKit.h"


@implementation SBR_StyleKitExported

#pragma mark Initialization
static UIImage *calibrateString;
+ (void)initialize
{
    calibrateString = [SBR_StyleKit imageForSettingsMenuGlowingTextButtonWithText:NSLocalizedString(@"Calibrate", nil) highlighted:NO];
}

#pragma mark Drawing Methods

+ (void)drawCircularCalibratorWithFrame: (CGRect)frame maximum: (CGFloat)maximum minimum: (CGFloat)minimum showExluded: (BOOL)showExluded excludeMinimum: (CGFloat)excludeMinimum excludeMaximum: (CGFloat)excludeMaximum;
{
    CGFloat offset = -90;
    maximum += offset;
    minimum += offset;
    excludeMinimum += offset;
    excludeMaximum += offset;
    
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    UIColor* outlineColor = [UIColor colorWithRed: 0.129 green: 0.675 blue: 0.988 alpha: 1];
    UIColor* inlineColor = [UIColor colorWithRed: 0.133 green: 0.216 blue: 0.231 alpha: 1];
    UIColor* backgroundColor = [UIColor colorWithRed: 0.082 green: 0.082 blue: 0.067 alpha: 1];
    UIColor* excludeOutlineColor = [UIColor colorWithRed: 0.915 green: 0.363 blue: 0.363 alpha: 1];
    UIColor* excludeInlineColor = [UIColor colorWithRed: 0.371 green: 0.249 blue: 0.249 alpha: 1];

    //// Image Declarations
    UIImage* gestureIcon = [UIImage imageNamed: @"gestureIcon"];


    //// Variable Declarations
    CGFloat minExcludedEnd = maximum;
    CGFloat minEnd = minimum - 90;
    CGFloat minimumMin = minimum;
    CGFloat minimumMax = excludeMinimum;
    CGFloat maxExcludedEnd = excludeMaximum - 90;
    CGFloat maxExcludedOutline = excludeMaximum;
    CGFloat gap = 2;
    CGFloat minExcludedEndRed = excludeMinimum - (90 + gap);
    CGFloat minExcludedOutlineRed = minExcludedEndRed + 90;
    CGFloat maxExcludedEndRed = gap + excludeMaximum;

    //// Group
    {
        //// Background Drawing
        UIBezierPath* backgroundPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(CGRectGetMinX(frame), CGRectGetMinY(frame), 180, 180)];
        [backgroundColor setFill];
        [backgroundPath fill];


        if (showExluded)
        {
            //// Inner 2 Drawing
            CGRect inner2Rect = CGRectMake(CGRectGetMinX(frame) + 4.5, CGRectGetMinY(frame) + 4.5, 171, 171);
            UIBezierPath* inner2Path = UIBezierPath.bezierPath;
            [inner2Path addArcWithCenter: CGPointMake(CGRectGetMidX(inner2Rect), CGRectGetMidY(inner2Rect)) radius: CGRectGetWidth(inner2Rect) / 2 startAngle: -maxExcludedOutline * M_PI/180 endAngle: -minExcludedEnd * M_PI/180 clockwise: YES];

            [inlineColor setStroke];
            inner2Path.lineWidth = 9;
            [inner2Path stroke];


            //// Negative End 2 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 90, CGRectGetMinY(frame) + 90);
            CGContextRotateCTM(context, -maxExcludedEnd * M_PI / 180);

            UIBezierPath* negativeEnd2Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(-0.5, -90, 1, 15) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(0.5, 0.5)];
            [negativeEnd2Path closePath];
            [outlineColor setFill];
            [negativeEnd2Path fill];

            CGContextRestoreGState(context);


            //// Outline 2 Drawing
            CGRect outline2Rect = CGRectMake(CGRectGetMinX(frame) + 0.5, CGRectGetMinY(frame) + 0.5, 179, 179);
            UIBezierPath* outline2Path = UIBezierPath.bezierPath;
            [outline2Path addArcWithCenter: CGPointMake(CGRectGetMidX(outline2Rect), CGRectGetMidY(outline2Rect)) radius: CGRectGetWidth(outline2Rect) / 2 startAngle: -maxExcludedOutline * M_PI/180 endAngle: -minExcludedEnd * M_PI/180 clockwise: YES];

            [outlineColor setStroke];
            outline2Path.lineWidth = 1;
            [outline2Path stroke];


            //// Positive End 2 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 90, CGRectGetMinY(frame) + 90);
            CGContextRotateCTM(context, -minExcludedEnd * M_PI / 180);

            UIBezierPath* positiveEnd2Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(75, -0.5, 15, 1) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(0.5, 0.5)];
            [positiveEnd2Path closePath];
            [outlineColor setFill];
            [positiveEnd2Path fill];

            CGContextRestoreGState(context);
        }


        //// Inner Drawing
        CGRect innerRect = CGRectMake(CGRectGetMinX(frame) + 4.5, CGRectGetMinY(frame) + 4.5, 171, 171);
        UIBezierPath* innerPath = UIBezierPath.bezierPath;
        [innerPath addArcWithCenter: CGPointMake(CGRectGetMidX(innerRect), CGRectGetMidY(innerRect)) radius: CGRectGetWidth(innerRect) / 2 startAngle: -minimumMin * M_PI/180 endAngle: -minimumMax * M_PI/180 clockwise: YES];

        [inlineColor setStroke];
        innerPath.lineWidth = 9;
        [innerPath stroke];


        //// Negative End Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + 90, CGRectGetMinY(frame) + 90);
        CGContextRotateCTM(context, -minEnd * M_PI / 180);

        UIBezierPath* negativeEndPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(-0.5, -90, 1, 15) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(0.5, 0.5)];
        [negativeEndPath closePath];
        [outlineColor setFill];
        [negativeEndPath fill];

        CGContextRestoreGState(context);


        //// Outline Drawing
        CGRect outlineRect = CGRectMake(CGRectGetMinX(frame) + 0.5, CGRectGetMinY(frame) + 0.5, 179, 179);
        UIBezierPath* outlinePath = UIBezierPath.bezierPath;
        [outlinePath addArcWithCenter: CGPointMake(CGRectGetMidX(outlineRect), CGRectGetMidY(outlineRect)) radius: CGRectGetWidth(outlineRect) / 2 startAngle: -minimumMin * M_PI/180 endAngle: -minimumMax * M_PI/180 clockwise: YES];

        [outlineColor setStroke];
        outlinePath.lineWidth = 1;
        [outlinePath stroke];


        //// Positive End Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + 90, CGRectGetMinY(frame) + 90);
        CGContextRotateCTM(context, -minimumMax * M_PI / 180);

        UIBezierPath* positiveEndPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(75, -0.5, 15, 1) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(0.5, 0.5)];
        [positiveEndPath closePath];
        [outlineColor setFill];
        [positiveEndPath fill];

        CGContextRestoreGState(context);


        if (showExluded)
        {
            //// Inner 3 Drawing
            CGRect inner3Rect = CGRectMake(CGRectGetMinX(frame) + 4.5, CGRectGetMinY(frame) + 4.5, 171, 171);
            UIBezierPath* inner3Path = UIBezierPath.bezierPath;
            [inner3Path addArcWithCenter: CGPointMake(CGRectGetMidX(inner3Rect), CGRectGetMidY(inner3Rect)) radius: CGRectGetWidth(inner3Rect) / 2 startAngle: -minExcludedOutlineRed * M_PI/180 endAngle: -maxExcludedEndRed * M_PI/180 clockwise: YES];

            [excludeInlineColor setStroke];
            inner3Path.lineWidth = 9;
            [inner3Path stroke];


            //// Negative End 3 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 90, CGRectGetMinY(frame) + 90);
            CGContextRotateCTM(context, -minExcludedEndRed * M_PI / 180);

            UIBezierPath* negativeEnd3Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(-0.5, -90, 1, 15) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(0.5, 0.5)];
            [negativeEnd3Path closePath];
            [excludeOutlineColor setFill];
            [negativeEnd3Path fill];

            CGContextRestoreGState(context);


            //// Outline 3 Drawing
            CGRect outline3Rect = CGRectMake(CGRectGetMinX(frame) + 0.5, CGRectGetMinY(frame) + 0.5, 179, 179);
            UIBezierPath* outline3Path = UIBezierPath.bezierPath;
            [outline3Path addArcWithCenter: CGPointMake(CGRectGetMidX(outline3Rect), CGRectGetMidY(outline3Rect)) radius: CGRectGetWidth(outline3Rect) / 2 startAngle: -minExcludedOutlineRed * M_PI/180 endAngle: -maxExcludedEndRed * M_PI/180 clockwise: YES];

            [excludeOutlineColor setStroke];
            outline3Path.lineWidth = 1;
            [outline3Path stroke];


            //// Positive End 3 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 90, CGRectGetMinY(frame) + 90);
            CGContextRotateCTM(context, -maxExcludedEndRed * M_PI / 180);

            UIBezierPath* positiveEnd3Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(75, -0.5, 15, 1) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(0.5, 0.5)];
            [positiveEnd3Path closePath];
            [excludeOutlineColor setFill];
            [positiveEnd3Path fill];

            CGContextRestoreGState(context);
        }


        //// Dive Icon Drawing
        CGRect diveIconRect = CGRectMake(CGRectGetMinX(frame) + 54, CGRectGetMinY(frame) + 44, 73, 77);
        UIBezierPath* diveIconPath = [UIBezierPath bezierPathWithRect: diveIconRect];
        CGContextSaveGState(context);
        [diveIconPath addClip];
        [gestureIcon drawInRect: diveIconRect];
        CGContextRestoreGState(context);


        //// Calibrate Message Drawing
        CGRect calibrateMessageRect = CGRectMake(CGRectGetMinX(frame) + 40, CGRectGetMinY(frame) + 128, 97, 17);
        UIBezierPath* calibrateMessagePath = [UIBezierPath bezierPathWithRect: calibrateMessageRect];
        CGContextSaveGState(context);
        [calibrateMessagePath addClip];
        [calibrateString drawInRect: calibrateMessageRect];
        CGContextRestoreGState(context);
    }
}

@end
