//
//  SBR_StyleKitExported.m
//  Lab-VC-Transitions
//
//  Created by Chris Mitchelmore on 31/05/2014.
//  Copyright (c) 2014 Air Craft. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "SBR_StyleKitExported.h"


@implementation SBR_StyleKitExported

#pragma mark Initialization

+ (void)initialize
{
}

#pragma mark Drawing Methods

+ (void)drawCircularCalibratorWithFrame: (CGRect)frame maximum: (CGFloat)maximum minimum: (CGFloat)minimum showExluded: (BOOL)showExluded excludeMinimum: (CGFloat)excludeMinimum excludeMaximum: (CGFloat)excludeMaximum;
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    UIColor* outlineColor = [UIColor colorWithRed: 0.129 green: 0.675 blue: 0.988 alpha: 1];
    UIColor* inlineColor = [UIColor colorWithRed: 0.133 green: 0.216 blue: 0.231 alpha: 1];
    UIColor* backgroundColor = [UIColor colorWithRed: 0.082 green: 0.082 blue: 0.067 alpha: 1];
    UIColor* excludeOutlineColor = [UIColor colorWithRed: 0.915 green: 0.363 blue: 0.363 alpha: 1];
    UIColor* excludeInlineColor = [UIColor colorWithRed: 0.371 green: 0.249 blue: 0.249 alpha: 1];

    //// Image Declarations
    UIImage* gestureIcon = [UIImage imageNamed: @"gestureIcon"];
    UIImage* calibrateString = [UIImage imageNamed: @"calibrateString"];

    //// Variable Declarations
    CGFloat minExcludedEnd = maximum;
    CGFloat minEnd = minimum - 90;
    CGFloat minimumMin = minimum;
    CGFloat minimumMax = excludeMinimum;
    CGFloat maxExcludedEnd = excludeMaximum - 90;
    CGFloat maxExcludedOutline = excludeMaximum;
    CGFloat gap = 5;
    CGFloat minExcludedEndRed = excludeMinimum - 90 + gap;
    CGFloat minExcludedOutlineRed = minExcludedEndRed + 90;
    CGFloat maxExcludedEndRed = gap + excludeMaximum;

    //// Group
    {
        //// Background Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + 8.2, CGRectGetMinY(frame) + 7.4);
        CGContextScaleCTM(context, 1.8, 1.8);

        UIBezierPath* backgroundPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(0, 0, 102, 102)];
        [backgroundColor setFill];
        [backgroundPath fill];

        CGContextRestoreGState(context);


        if (showExluded)
        {
            //// Inner 2 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 17, CGRectGetMinY(frame) + 16);
            CGContextScaleCTM(context, 1.8, 1.8);

            CGRect inner2Rect = CGRectMake(0, 0, 92, 92);
            UIBezierPath* inner2Path = UIBezierPath.bezierPath;
            [inner2Path addArcWithCenter: CGPointMake(CGRectGetMidX(inner2Rect), CGRectGetMidY(inner2Rect)) radius: CGRectGetWidth(inner2Rect) / 2 startAngle: -maxExcludedOutline * M_PI/180 endAngle: -minExcludedEnd * M_PI/180 clockwise: YES];

            [inlineColor setStroke];
            inner2Path.lineWidth = 6;
            [inner2Path stroke];

            CGContextRestoreGState(context);


            //// Negative End 2 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 100, CGRectGetMinY(frame) + 99);
            CGContextRotateCTM(context, -maxExcludedEnd * M_PI / 180);
            CGContextScaleCTM(context, 1.8, 1.8);

            UIBezierPath* negativeEnd2Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(-1, -51, 2, 9) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(1, 1)];
            [negativeEnd2Path closePath];
            [outlineColor setFill];
            [negativeEnd2Path fill];

            CGContextRestoreGState(context);


            //// Outline 2 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 10, CGRectGetMinY(frame) + 9);
            CGContextScaleCTM(context, 1.8, 1.8);

            CGRect outline2Rect = CGRectMake(0, 0, 100, 100);
            UIBezierPath* outline2Path = UIBezierPath.bezierPath;
            [outline2Path addArcWithCenter: CGPointMake(CGRectGetMidX(outline2Rect), CGRectGetMidY(outline2Rect)) radius: CGRectGetWidth(outline2Rect) / 2 startAngle: -maxExcludedOutline * M_PI/180 endAngle: -minExcludedEnd * M_PI/180 clockwise: YES];

            [outlineColor setStroke];
            outline2Path.lineWidth = 2;
            [outline2Path stroke];

            CGContextRestoreGState(context);


            //// Positive End 2 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 100, CGRectGetMinY(frame) + 99);
            CGContextRotateCTM(context, -minExcludedEnd * M_PI / 180);
            CGContextScaleCTM(context, 1.8, 1.8);

            UIBezierPath* positiveEnd2Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(42, -0.5, 9, 2) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(1, 1)];
            [positiveEnd2Path closePath];
            [outlineColor setFill];
            [positiveEnd2Path fill];

            CGContextRestoreGState(context);
        }


        //// Inner Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + 17, CGRectGetMinY(frame) + 16);
        CGContextScaleCTM(context, 1.8, 1.8);

        CGRect innerRect = CGRectMake(0, 0, 92, 92);
        UIBezierPath* innerPath = UIBezierPath.bezierPath;
        [innerPath addArcWithCenter: CGPointMake(CGRectGetMidX(innerRect), CGRectGetMidY(innerRect)) radius: CGRectGetWidth(innerRect) / 2 startAngle: -minimumMin * M_PI/180 endAngle: -minimumMax * M_PI/180 clockwise: YES];

        [inlineColor setStroke];
        innerPath.lineWidth = 6;
        [innerPath stroke];

        CGContextRestoreGState(context);


        //// Negative End Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + 100, CGRectGetMinY(frame) + 99);
        CGContextRotateCTM(context, -minEnd * M_PI / 180);
        CGContextScaleCTM(context, 1.8, 1.8);

        UIBezierPath* negativeEndPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(-1, -51, 2, 9) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(1, 1)];
        [negativeEndPath closePath];
        [outlineColor setFill];
        [negativeEndPath fill];

        CGContextRestoreGState(context);


        //// Outline Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + 10, CGRectGetMinY(frame) + 9);
        CGContextScaleCTM(context, 1.8, 1.8);

        CGRect outlineRect = CGRectMake(0, 0, 100, 100);
        UIBezierPath* outlinePath = UIBezierPath.bezierPath;
        [outlinePath addArcWithCenter: CGPointMake(CGRectGetMidX(outlineRect), CGRectGetMidY(outlineRect)) radius: CGRectGetWidth(outlineRect) / 2 startAngle: -minimumMin * M_PI/180 endAngle: -minimumMax * M_PI/180 clockwise: YES];

        [outlineColor setStroke];
        outlinePath.lineWidth = 2;
        [outlinePath stroke];

        CGContextRestoreGState(context);


        //// Positive End Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + 100, CGRectGetMinY(frame) + 99);
        CGContextRotateCTM(context, -minimumMax * M_PI / 180);
        CGContextScaleCTM(context, 1.8, 1.8);

        UIBezierPath* positiveEndPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(42, -0.5, 9, 2) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(1, 1)];
        [positiveEndPath closePath];
        [outlineColor setFill];
        [positiveEndPath fill];

        CGContextRestoreGState(context);


        if (showExluded)
        {
            //// Inner 3 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 17, CGRectGetMinY(frame) + 16);
            CGContextScaleCTM(context, 1.8, 1.8);

            CGRect inner3Rect = CGRectMake(0, 0, 92, 92);
            UIBezierPath* inner3Path = UIBezierPath.bezierPath;
            [inner3Path addArcWithCenter: CGPointMake(CGRectGetMidX(inner3Rect), CGRectGetMidY(inner3Rect)) radius: CGRectGetWidth(inner3Rect) / 2 startAngle: -minExcludedOutlineRed * M_PI/180 endAngle: -maxExcludedEndRed * M_PI/180 clockwise: YES];

            [excludeInlineColor setStroke];
            inner3Path.lineWidth = 6;
            [inner3Path stroke];

            CGContextRestoreGState(context);


            //// Negative End 3 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 100, CGRectGetMinY(frame) + 99);
            CGContextRotateCTM(context, -minExcludedEndRed * M_PI / 180);
            CGContextScaleCTM(context, 1.8, 1.8);

            UIBezierPath* negativeEnd3Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(-1, -51, 2, 9) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(1, 1)];
            [negativeEnd3Path closePath];
            [excludeOutlineColor setFill];
            [negativeEnd3Path fill];

            CGContextRestoreGState(context);


            //// Outline 3 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 10, CGRectGetMinY(frame) + 9);
            CGContextScaleCTM(context, 1.8, 1.8);

            CGRect outline3Rect = CGRectMake(0, 0, 100, 100);
            UIBezierPath* outline3Path = UIBezierPath.bezierPath;
            [outline3Path addArcWithCenter: CGPointMake(CGRectGetMidX(outline3Rect), CGRectGetMidY(outline3Rect)) radius: CGRectGetWidth(outline3Rect) / 2 startAngle: -minExcludedOutlineRed * M_PI/180 endAngle: -maxExcludedEndRed * M_PI/180 clockwise: YES];

            [excludeOutlineColor setStroke];
            outline3Path.lineWidth = 2;
            [outline3Path stroke];

            CGContextRestoreGState(context);


            //// Positive End 3 Drawing
            CGContextSaveGState(context);
            CGContextTranslateCTM(context, CGRectGetMinX(frame) + 100, CGRectGetMinY(frame) + 99);
            CGContextRotateCTM(context, -maxExcludedEndRed * M_PI / 180);
            CGContextScaleCTM(context, 1.8, 1.8);

            UIBezierPath* positiveEnd3Path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(42, -0.5, 9, 2) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(1, 1)];
            [positiveEnd3Path closePath];
            [excludeOutlineColor setFill];
            [positiveEnd3Path fill];

            CGContextRestoreGState(context);
        }


        //// Dive Icon Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + 51, CGRectGetMinY(frame) + 49);
        CGContextScaleCTM(context, 0.5, 0.5);

        CGRect diveIconRect = CGRectMake(0, 0, 200, 200);
        UIBezierPath* diveIconPath = [UIBezierPath bezierPathWithRect: diveIconRect];
        CGContextSaveGState(context);
        [diveIconPath addClip];
        [gestureIcon drawInRect: CGRectMake(floor(CGRectGetMinX(diveIconRect) + 0.5), floor(CGRectGetMinY(diveIconRect) + 0.5), gestureIcon.size.width, gestureIcon.size.height)];
        CGContextRestoreGState(context);

        CGContextRestoreGState(context);


        //// Calibrate Message Drawing
        CGRect calibrateMessageRect = CGRectMake(CGRectGetMinX(frame) + 51, CGRectGetMinY(frame) + 149, 100, 20);
        UIBezierPath* calibrateMessagePath = [UIBezierPath bezierPathWithRect: calibrateMessageRect];
        CGContextSaveGState(context);
        [calibrateMessagePath addClip];
        [calibrateString drawInRect: CGRectMake(floor(CGRectGetMinX(calibrateMessageRect) + 0.5), floor(CGRectGetMinY(calibrateMessageRect) + 0.5), calibrateString.size.width, calibrateString.size.height)];
        CGContextRestoreGState(context);
    }
}

@end
