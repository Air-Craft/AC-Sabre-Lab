//
//  StyleKitName.m
//  ProjectName
//
//  Created by AuthorName on 28/05/2014.
//  Copyright (c) 2014 CompanyName. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "StyleKitName.h"


@implementation StyleKitName

#pragma mark Initialization

+ (void)initialize
{
}

#pragma mark Drawing Methods

+ (void)drawCircularCalibratorWithFrame: (CGRect)frame minAngle: (CGFloat)minAngle maxAngle: (CGFloat)maxAngle;
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    UIColor* outlineColor = [UIColor colorWithRed: 0.129 green: 0.675 blue: 0.988 alpha: 1];
    UIColor* inlineColor = [UIColor colorWithRed: 0.133 green: 0.216 blue: 0.231 alpha: 1];
    UIColor* backgroundColor = [UIColor colorWithRed: 0.082 green: 0.082 blue: 0.067 alpha: 1];

    //// Variable Declarations
    CGFloat minEnd = minAngle - 90;
    CGFloat minOutline = minAngle;
    CGFloat maxEnd = maxAngle;
    CGFloat scale = (MIN(frame.size.width,frame.size.height) - 10 )/100.0;
    //// Group
    {
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame)+5, CGRectGetMinY(frame)+5);
        CGContextScaleCTM(context, scale, scale);



        //// Background Drawing
        UIBezierPath* backgroundPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-1, -1, 102, 102)];
        [backgroundColor setFill];
        [backgroundPath fill];


        //// Inner Drawing
        CGRect innerRect = CGRectMake(4, 4, 92, 92);
        UIBezierPath* innerPath = UIBezierPath.bezierPath;
        [innerPath addArcWithCenter: CGPointMake(CGRectGetMidX(innerRect), CGRectGetMidY(innerRect)) radius: CGRectGetWidth(innerRect) / 2 startAngle: -minOutline * M_PI/180 endAngle: -maxEnd * M_PI/180 clockwise: YES];

        [inlineColor setStroke];
        innerPath.lineWidth = 6;
        [innerPath stroke];


        //// Negative End Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 50, 50);
        CGContextRotateCTM(context, -(minEnd - 360) * M_PI / 180);

        UIBezierPath* negativeEndPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(-1, -51, 2, 9) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(1, 1)];
        [negativeEndPath closePath];
        [outlineColor setFill];
        [negativeEndPath fill];

        CGContextRestoreGState(context);


        //// Outline Drawing
        CGRect outlineRect = CGRectMake(0, 0, 100, 100);
        UIBezierPath* outlinePath = UIBezierPath.bezierPath;
        [outlinePath addArcWithCenter: CGPointMake(CGRectGetMidX(outlineRect), CGRectGetMidY(outlineRect)) radius: CGRectGetWidth(outlineRect) / 2 startAngle: -minOutline * M_PI/180 endAngle: -maxEnd * M_PI/180 clockwise: YES];

        [outlineColor setStroke];
        outlinePath.lineWidth = 2;
        [outlinePath stroke];


        //// Positive End Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 50, 50);
        CGContextRotateCTM(context, -(maxEnd - 360) * M_PI / 180);

        UIBezierPath* positiveEndPath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(42, -0.5, 9, 2) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(1, 1)];
        [positiveEndPath closePath];
        [outlineColor setFill];
        [positiveEndPath fill];

        CGContextRestoreGState(context);



        CGContextRestoreGState(context);
    }
}

@end
